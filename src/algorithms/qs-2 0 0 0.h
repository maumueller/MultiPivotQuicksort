    // Automatically generated by invoking
    // ruby gen_k_pivot_algorithm.rb with parameters
    //  2 0 0 0 
    #include <algorithm>

    namespace qsort2000{

    template <typename Iterator>
    void sort(Iterator left, Iterator right)
    {
        typedef typename std::iterator_traits<Iterator>::value_type value_type;
        if (right - left < 500)
        {
            qsort3::three_pivot(left, right);
        }
        else
        {
        networks::sort2(*(left +  0), *(right - 0));

        value_type p1 = *(left + 0);
        value_type p2 = *(right - 0);

        Iterator g1 = left + 1;

        Iterator i = left + 1;
        Iterator j = right - 1;

        while (i <= j)
        {
            while (*i < p2)
            {
                if (*i > p1)
                {
                    i++; 
                }
                else
                {
                        rotations::rotate2(*i, *g1);
                        i++; g1++; 
                }
            }
            while (*j > p2)
            {
                    j--; 
            }
            if (i <= j)
            {
                if (*j > p1)
                {
                    // rotate a2 and a1 elements
                    rotations::rotate2(*i, *j);
                    i++, j--;
                }
                else
                {
                    // rotate a2 and a0 elements
                    rotations::rotate3(*i, *g1, *j);
                    i++, j--, g1++;
                }
            }
        }
        rotations::rotate2(*(left + 0), *(g1 - 1));

        rotations::rotate2(*(right - 0), *(j + 1));

        sort(left, g1 - 2);
        sort(g1 - 0, j);
        sort(j + 2, right);
    }
}

template <typename ValueType>
void qsort()
{
    assert( g_input_size % sizeof(ValueType) == 0 );

    ValueType* input = (ValueType*)g_input;
    size_t n = g_input_size / sizeof(ValueType);

    sort(input, input + n - 1);
}

CONTESTANT_REGISTER_ALL(qsort, "qsort2000", "Quicksort, 2 pivots");

} // namespace
