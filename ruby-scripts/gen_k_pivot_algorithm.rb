# generate k pivot quicksort algorithm
# with given sampling technique


def print_usage
    puts "Usage: ruby gen_k_pivot_algorithm <k> <t1> ... <t_k+1>"
    exit(1)
end

def get_rotate_string_left(x, level)
    indent = " " * (4 * (level + 5))
    if level > 0
        print indent + "rotations::rotate#{level + 1}(*i, "
        level.downto(1) do |i|
            print "*g#{x + i}"
            print ", " unless i == 1
        end
        puts ");"
    end
    print indent + "i++; "
    level.downto(1) do |i|
        print "g#{x + i}++; "
    end
    puts "\n" 
end

def get_rotate_string_right(x, level)
    indent = " " * (4 * (level + 5))
    if level > 0
        print indent + "rotations::rotate#{level + 1}(*j, "
        level.downto(1) do |i|
            print "*g#{x - i - 1}"
            print ", " unless i == 1
        end
        puts ");"
    end
    print indent + "j--; "
    level.downto(1) do |i|
        print "g#{x - i - 1}--; "
    end
    puts "\n" 
end

def get_total_rotate_string(q, p, indent)
    indent = " " * (4 * (indent + 5))
    puts indent + "// rotate a" + p.to_s + " and a" + q.to_s + " elements"
    print indent + "rotations::rotate#{p - q + 1}(*i, "
    $g_left_max.downto(q + 1) do |i|
        print "*g#{i}, "
    end
    print "*j"
    ($g_left_max + 1).upto(p - 1) do |i|
        print ", *g#{i}"
    end
    print ");\n" 
    print indent + "i++, j--"
    $g_left_max.downto(q + 1) do |i|
        print ", g#{i}++"
    end
    ($g_left_max + 1).upto(p - 1) do |i|
        print ", g#{i}--"
    end
    print ";\n"
end

def recurse_left(x, level)
    if x == 0
        get_rotate_string_left(x, level)
        return
    end
    indent = " " * (4 * (level + 4))
    puts indent + "if (*i > p#{x})"
    puts indent + "{"
    get_rotate_string_left(x, level)
    puts indent + "}"
    puts indent + "else"
    puts indent + "{"
    recurse_left(x - 1, level + 1) 
    puts indent + "}"
end

def recurse_right(x, level)
    if x == $k + 1
        get_rotate_string_right(x, level)
        return
    end   
    indent = " " * (4 * (level + 4))
    puts indent + "if (*j < p#{x})"
    puts indent + "{"
    get_rotate_string_right(x, level)
    puts indent + "}"
    puts indent + "else"
    puts indent + "{"
    recurse_right(x + 1, level + 1)
    puts indent + "}"
end

def recurse_move_left(x, level)
    if x == $k + 1
        recurse_move_right($g_left_max, 0, x - 1, level)   
        return
    end
    indent = " " * (4 * (level + 4))
    puts indent + "if (*i < p#{x})"
    puts indent + "{"
    recurse_move_right($g_left_max, 0, x - 1, level + 1)
    puts indent + "}"
    puts indent + "else"
    puts indent + "{"
    recurse_move_left(x + 1, level + 1) 
    puts indent + "}"
end

def recurse_move_right(x, level, i_class, i_level)
    if x == 0
        get_total_rotate_string(0, i_class, level + i_level - 1) 
        return 
    end
    indent = " " * (4 * (level + i_level + 4))
    puts indent + "if (*j > p#{x})"
    puts indent + "{"
    get_total_rotate_string(x, i_class, level + i_level)
    puts indent + "}"
    puts indent + "else"
    puts indent + "{"
    recurse_move_right(x - 1, level + 1, i_class, i_level)
    puts indent + "}"
end

$k = ARGV[0].to_i
print_usage unless ARGV.length == $k + 2

use_insertion_sort = false

# this is the index of the right-most g-iterator 
# left of the i pointer.

$g_left_max = (($k - 1) / 2.0).ceil

# the index of the middle pivot, starting from 0
# (the left candidate for even number of pivots).
$med_pivot_index = (($k - 2) / 2.0).ceil


# number of samples in groups
$t = []

1.upto($k + 1) do |i|
    $t.push ARGV[i].to_i
end

# algoname consists of number of pivots and number of samples
$algoname = "qsort" + $k.to_s + $t.inject("") {|str, x| str += x.to_s}

# the number of sample elements (without pivots)
$kappa = $t.inject { |sum, x| sum += x}

# calculate where the pivots lie in the sorted sample
tmp = 0
$pivot_positions = $t[0..-2].map {|x| x += tmp; tmp = x}
$pivot_positions = $pivot_positions.map.with_index {|x, i| x += i}

# Header of cpp file

if use_insertion_sort
    puts <<-EOS
    // Automatically generated by invoking
    // ruby gen_k_pivot_algorithm.rb with parameters
    // #{ARGV.inject(" ") {|str, x| str += x.to_s + " "}}
    #include <algorithm>

    namespace #{$algoname}{

    template <typename Iterator>
    void sort(Iterator left, Iterator right)
    {
        typedef typename std::iterator_traits<Iterator>::value_type value_type;
        if (right - left < #{[27, 24 + $kappa+$k + 1].max.to_s})
        {
            InsertionSort(left, right - left + 1);
        }
        else
        {
    EOS
else
    puts <<-EOS
    // Automatically generated by invoking
    // ruby gen_k_pivot_algorithm.rb with parameters
    // #{ARGV.inject(" ") {|str, x| str += x.to_s + " "}}
    #include <algorithm>

    namespace #{$algoname}{

    template <typename Iterator>
    void sort(Iterator left, Iterator right)
    {
        typedef typename std::iterator_traits<Iterator>::value_type value_type;
        if (right - left < 500)
        {
            qsort3::three_pivot(left, right);
        }
        else
        {
    EOS
end

# sort samples
if $k + $kappa > 1

    left_order = []
    offset = $med_pivot_index + 1
    0.upto($pivot_positions[$med_pivot_index]) do |i|
        if (j = $pivot_positions.find_index(i))
            left_order.push(j)
        else
            left_order.push(offset)
            offset += 1
        end
    end

    right_order = []
    offset = $k - ($med_pivot_index + 1)  + 
        $t[$med_pivot_index + 1..-1].inject(0) {|sum,x| sum += x} - 1
    ($pivot_positions[$med_pivot_index] + 1).upto($kappa + $k - 1) do |i|
        if (j = $pivot_positions.find_index(i))
            right_order.push($k - j - 1)
        else
            right_order.push(offset)
            offset -= 1
        end
    end

    # print sort string
    print "        networks::sort" + ($kappa + $k).to_s + "("
    left_order.each do |offset|
        print "*(left +  " + offset.to_s + "), " 
    end
    right_order[0..-2].each do |offset|
        print "*(right - " + offset.to_s + "), "
    end
    if not right_order.empty?
        print "*(right - " + right_order[-1].to_s + ")"
    end
    print ");\n\n"
end

# initialize pivots

1.upto($med_pivot_index + 1) do |i|
    puts "        value_type p" + i.to_s + " = *(left + " + (i - 1).to_s + ");"
end

($med_pivot_index + 2).upto($k) do |i|
    puts "        value_type p" + i.to_s + " = *(right - " + ($k - i).to_s + ");"
end

puts ""

# initialize g iterators
left_offset = $med_pivot_index + 1 + $t[0]

1.upto($g_left_max) do |i|
    puts "        Iterator g" + i.to_s + " = left + " + left_offset.to_s  + ";"
    left_offset += $t[i]
end

right_offset = $k - ($med_pivot_index + 1) + $t[-1]

($k - 1).downto($g_left_max + 1) do |i|
    puts "        Iterator g" + i.to_s + " = right - " + right_offset.to_s  + ";"
    right_offset += $t[i]
end

puts ""

puts "        Iterator i = left + "  + 
    ($med_pivot_index + 1 + $t[0..$med_pivot_index].inject(0) {|sum, x| sum += x}).to_s + ";"
puts "        Iterator j = right - "  + 
    ($k - $med_pivot_index - 1 + $t[$med_pivot_index + 2..-1].inject(0) {|sum, x| sum += x}).to_s+ ";"
puts ""
puts "        while (i <= j)"
puts "        {"
puts "            while (*i < p#{$g_left_max + 1})"
puts "            {"
recurse_left($g_left_max, 0)
puts "            }"
puts "            while (*j > p#{$g_left_max + 1})"
puts "            {"
recurse_right($g_left_max + 2, 0)
puts "            }"
puts "            if (i <= j)"
puts "            {"
recurse_move_left($g_left_max + 2, 0)
puts "            }"
puts "        }"

# Move pivots to final position

subproblems = [[]]
($med_pivot_index + 1).downto(1) do |x|
    print "        rotations::rotate#{x + 1}(*(left + #{x - 1})"
    1.upto(x) do |y|
        if y == $med_pivot_index + 1 && $k.odd? 
            print ", *(i - #{$med_pivot_index - x + 2})"
            subproblems[0].unshift("i - #{$med_pivot_index - x + 1}")
            subproblems.unshift(["i - #{$med_pivot_index - x + 3}"])
        else
            print ", *(g#{y} - #{$med_pivot_index - x + 2})"
            if y == x
                subproblems[0].unshift("g#{y} - #{$med_pivot_index - x + 1}")
                subproblems.unshift(["g#{y} - #{$med_pivot_index - x + 3}"])
            end
        end
    end
    print ");\n"
end

subproblems[0].unshift("left")

# Find subproblems sorted in recursion.

puts ""

($k - $med_pivot_index - 1).downto(1) do |x|
    print "        rotations::rotate#{x + 1}(*(right - #{x - 1})"
    1.upto(x) do |y|
        if y == $k - $med_pivot_index - 1 && $k.even?
            print ", *(j + 1)"
            subproblems[-1] += ["j"]
            subproblems.push(["j + 2"])
        else
            print ", *(g#{$k - y} + #{$k - $med_pivot_index - x})"
            if y == x
                subproblems[-1] += ["g#{$k - y} + #{$k - $med_pivot_index - x - 1}"]
                subproblems.push(["g#{$k - y} + #{$k - $med_pivot_index - x + 1}"])
            end
        end
    end
    print ");\n"
end
subproblems[-1] += ["right"]

puts ""

# Print subproblems which are going to be sorted 
subproblems.each do |sub|
    puts "        sort(#{sub[0]}, #{sub[1]});"
end

#puts "        scanned_element_cnt +=  i - (left + " + left_offset.to_s  + ");"
#puts "        scanned_element_cnt +=  -j + right - " + left_offset.to_s  + ";"
#
#
#1.upto($g_left_max) do |i|
#    puts "        scanned_element_cnt +=  g" + i.to_s + " - (left + " + left_offset.to_s  + ");"
#    left_offset += $t[i]
#end
#
#($k - 1).downto($g_left_max + 1) do |i|
#    puts "        scanned_element_cnt +=  -g" + i.to_s + " + right - " + right_offset.to_s  + ";"
#    right_offset += $t[i]
#end

puts "    }"
puts "}"
puts ""

puts <<-EOS
template <typename ValueType>
void qsort()
{
    assert( g_input_size % sizeof(ValueType) == 0 );

    ValueType* input = (ValueType*)g_input;
    size_t n = g_input_size / sizeof(ValueType);

    sort(input, input + n - 1);
}

CONTESTANT_REGISTER_ALL(qsort, "#{$algoname}", "Quicksort, #{$k} pivots");

} // namespace
EOS
